import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.Element;
import com.lowagie.text.Font;
import com.lowagie.text.PageSize;
import com.lowagie.text.Paragraph;
import com.lowagie.text.Rectangle;
import com.lowagie.text.pdf.PdfPTable;
import com.lowagie.text.pdf.PdfWriter;
import java.awt.HeadlessException;
import java.io.*;
import java.util.*;
import java.lang.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import javax.swing.JFileChooser;
import javax.swing.JTextField;


/**
 *
 * @author Abhi
 */


public class index extends javax.swing.JFrame {
    
    
    
    // Initializes an 4-order B+ tree
    int orderM =4;
    bplustree bpt = new bplustree(orderM);
  

    public static int p=0;
    public static int q=0;
    public index() {
        initComponents();
        table_update();
        slotinfo(p,q);
        callme();
    }
    
    private void callme(){
    
    String path="C:\\Users\\adars\\OneDrive\\Desktop\\FS_Mini\\FS\\ParkingSystem\\data.txt";
       File file=new File(path);
        try { 
            BufferedReader br=new BufferedReader(new FileReader(file));
           
            Object[] tablelines=br.lines().toArray();
            
           for (Object tableline : tablelines) {
               String line = tableline.toString().trim();
               String[] data=line.split(" ");
             
              
               if(!(line.equals(""))){
                try{bpt.insert(Integer.parseInt(data[7]),line);
                //System.out.println("update BPT");
                }
                catch(NumberFormatException e){
                 System.out.println("Insertion to bpt done");
               // String res=bpt.search(Integer.parseInt(data[7]));
                //System.out.println(res);
                //bpt.delete(Integer.parseInt(data[7]));
                //bpt.insert(Integer.parseInt(data[7]),line);
                }
                
                }
               else{
                 System.out.println("Non Empty File");
               }
           }
                 br.close();  
        } catch (IOException ex) {
            Logger.getLogger(index.class.getName()).log(Level.SEVERE, null, ex);
            System.out.println("B+ not created");
        }
    }
    //For the table clear when update, deletes old rows
    private void deleteAllRows( DefaultTableModel model) {
        for( int m = model.getRowCount() - 1; m >= 0; m-- ) {
            model.removeRow(m);
            System.out.println("Delete all rows");
        }
    }
 
    //Updates the Jtable
    private void table_update(){
       
       String path="C:\\Users\\adars\\OneDrive\\Desktop\\FS_Mini\\FS\\ParkingSystem\\data.txt";
       File file=new File(path);
        try { 
            BufferedReader br=new BufferedReader(new FileReader(file));
            DefaultTableModel model=(DefaultTableModel)jTable1.getModel();
            Object[] tablelines=br.lines().toArray();
            
           for (Object tableline : tablelines) {
               String line = tableline.toString().trim();
               String[] data=line.split(" ");
               model.addRow(data);
               //("table updated");
               jTable1.setAutoCreateRowSorter(true);
              
           }
                 br.close();  
        } catch (IOException ex) {
            Logger.getLogger(index.class.getName()).log(Level.SEVERE, null, ex);
            System.out.println("table update failed");
        }
 

    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        brand = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        nametxt = new javax.swing.JTextField();
        brandtxt = new javax.swing.JTextField();
        rctxt = new javax.swing.JTextField();
        contacttxt = new javax.swing.JTextField();
        gendertxt = new javax.swing.JComboBox<>();
        parkBut = new javax.swing.JButton();
        ReleaseBut = new javax.swing.JButton();
        UpdateBut = new javax.swing.JButton();
        ClearBut = new javax.swing.JButton();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        issuetxt = new com.toedter.calendar.JDateChooser();
        expirytxt = new com.toedter.calendar.JDateChooser();
        tracktxt = new javax.swing.JComboBox<>();
        jPanel2 = new javax.swing.JPanel();
        searchtxt = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        unavailabletxt = new javax.swing.JTextField();
        availabletxt = new javax.swing.JTextField();
        jLabel11 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        checkBut = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        reportExport = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(255, 216, 157));
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setForeground(java.awt.Color.orange);

        jLabel1.setFont(new java.awt.Font("Times New Roman", 1, 36)); // NOI18N
        jLabel1.setText("Parking Management System");

        jPanel1.setBackground(new java.awt.Color(242, 232, 227));
        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Vehicle Details", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Times New Roman", 1, 14), new java.awt.Color(0, 0, 0)));

        jLabel2.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jLabel2.setText("Name");

        brand.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        brand.setText("Brand");

        jLabel4.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jLabel4.setText("Gender");

        jLabel5.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jLabel5.setText("Parking Issued");

        jLabel6.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jLabel6.setText("RC No");

        jLabel7.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jLabel7.setText("Contact");

        rctxt.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rctxtActionPerformed(evt);
            }
        });

        gendertxt.setEditable(true);
        gendertxt.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Male", "Female" }));
        gendertxt.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                gendertxtItemStateChanged(evt);
            }
        });
        gendertxt.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                gendertxtActionPerformed(evt);
            }
        });

        parkBut.setText("Park");
        parkBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                parkButActionPerformed(evt);
            }
        });

        ReleaseBut.setText("Release");
        ReleaseBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ReleaseButActionPerformed(evt);
            }
        });

        UpdateBut.setText("Update");
        UpdateBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                UpdateButActionPerformed(evt);
            }
        });

        ClearBut.setText("Clear");
        ClearBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ClearButActionPerformed(evt);
            }
        });

        jLabel9.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jLabel9.setText("Parking Expiry");

        jLabel10.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jLabel10.setText("Track No");

        issuetxt.setBackground(new java.awt.Color(242, 232, 227));
        issuetxt.setDateFormatString("dd-MMM-yyyy");

        expirytxt.setBackground(new java.awt.Color(242, 232, 227));
        expirytxt.setDateFormatString("dd-MMM-yyyy");

        tracktxt.setEditable(true);
        tracktxt.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "1", "2", "3", "4", "5" }));
        tracktxt.setKeySelectionManager(null);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(34, 34, 34)
                        .addComponent(parkBut, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(43, 43, 43)
                        .addComponent(ReleaseBut, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(47, 47, 47)
                        .addComponent(UpdateBut, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(45, 45, 45)
                        .addComponent(ClearBut, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(19, 19, 19)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(brand, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(48, 48, 48)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(gendertxt, javax.swing.GroupLayout.Alignment.LEADING, 0, 112, Short.MAX_VALUE)
                            .addComponent(nametxt, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(brandtxt, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(issuetxt, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(59, 59, 59)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabel7, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabel9, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabel10, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(44, 44, 44)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(contacttxt)
                            .addComponent(rctxt)
                            .addComponent(expirytxt, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(tracktxt, 0, 110, Short.MAX_VALUE))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jLabel6)
                    .addComponent(rctxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(nametxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(brand)
                    .addComponent(jLabel7)
                    .addComponent(brandtxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(contacttxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(24, 24, 24)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(gendertxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel10)
                    .addComponent(tracktxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(26, 26, 26)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jLabel5)
                                .addComponent(jLabel9))
                            .addComponent(issuetxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 40, Short.MAX_VALUE)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(ReleaseBut, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(UpdateBut, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(ClearBut, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(parkBut, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(3, 3, 3)
                        .addComponent(expirytxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );

        jPanel2.setBackground(new java.awt.Color(242, 232, 227));
        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder(null, " ", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Times New Roman", 1, 14), new java.awt.Color(0, 0, 0)));

        jLabel8.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jLabel8.setText("Check");

        unavailabletxt.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                unavailabletxtActionPerformed(evt);
            }
        });

        availabletxt.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                availabletxtActionPerformed(evt);
            }
        });

        jLabel11.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jLabel11.setText("Available");

        jLabel13.setFont(new java.awt.Font("Times New Roman", 1, 18)); // NOI18N
        jLabel13.setText("Slot Information");

        jLabel12.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jLabel12.setText("       Unavailable");

        checkBut.setText("Check");
        checkBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkButActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(35, 35, 35)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel11, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(33, 33, 33)
                        .addComponent(jLabel12, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(availabletxt, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(unavailabletxt, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(50, 50, 50))))
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(75, 75, 75)
                .addComponent(jLabel13)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addGap(25, 25, 25)
                .addComponent(jLabel8, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(searchtxt, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(checkBut, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(20, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addGap(19, 19, 19)
                .addComponent(jLabel13)
                .addGap(57, 57, 57)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel11)
                    .addComponent(jLabel12))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 9, Short.MAX_VALUE)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(availabletxt, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(unavailabletxt, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(70, 70, 70)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel8)
                    .addComponent(searchtxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(checkBut))
                .addGap(23, 23, 23))
        );

        jTable1.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "RC No", "Name", "Brand", "Contact", "Gender", "Issue", "Expiry", "Track"
            }
        ));
        jTable1.setShowHorizontalLines(false);
        jTable1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jTable1MouseClicked(evt);
            }
        });
        jScrollPane3.setViewportView(jTable1);

        reportExport.setText("Generate Report");
        reportExport.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                reportExportActionPerformed(evt);
            }
        });

        jPanel3.setBackground(new java.awt.Color(242, 230, 225));

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1026, Short.MAX_VALUE)
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 491, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane3)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 459, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(122, 122, 122)
                        .addComponent(reportExport, javax.swing.GroupLayout.PREFERRED_SIZE, 143, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(31, 31, 31)
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 63, Short.MAX_VALUE)
                        .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(49, 49, 49))
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(18, 18, 18)
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(46, 46, 46)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 110, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(reportExport, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void rctxtActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rctxtActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_rctxtActionPerformed

    private void gendertxtActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_gendertxtActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_gendertxtActionPerformed

    private void gendertxtItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_gendertxtItemStateChanged
        // TODO add your handling code here:
    }//GEN-LAST:event_gendertxtItemStateChanged
   
    //Sets value to the slot Show. We can draw lap wise blocks to make it visual
    public void slotinfo(int p,int q){
        File file2=new File("slots.txt");
       // System.out.println("Slot info called");
        try{
            BufferedReader br = new BufferedReader(new FileReader(file2));
            String r;
            while((r=br.readLine())!=null){
                System.out.println(r);
                String[] res=r.split(" ");
                String stat=res[1];                
                if("Available".equals(stat)){
                    p = p+1;
                }else {
                    q = q+1;
                }
               //System.out.println("Slot info shown");
            }
            br.close();
            
        }catch(IOException e){
                    System.out.println(e);
                    System.out.println("Slot ifno display failed");
            }
        
        String pp=String.valueOf(p);
        availabletxt.setText(pp);
        String qq=String.valueOf(q);
        unavailabletxt.setText(qq);
    }
    
    //This Removes the Filled and makes it Available
    public void unfill(String track){
        q-=1;
        p+=1;
        slotinfo(p,q);
        File temp2=new File("temp2.txt");
        File file2=new File("slots.txt");
        try{
            PrintWriter pw = new PrintWriter(new FileOutputStream(temp2,true));
            BufferedReader br = new BufferedReader(new FileReader(file2));
            String r;
            while((r=br.readLine())!=null){
                
                String[] res=r.split(" ");
                String trackt=res[0];
                //System.out.println(track+" "+trackt);
                if(trackt.equals(track)){
                    String b=track+" "+"Available"+" ";
                    pw.println(b);
                }
                else{
                    pw.println(r);
                }
            }
            System.out.println("Unfilling done");
            bpt.delete(Integer.parseInt(track));
            pw.flush();
            pw.close();
            br.close();
            try{
                file2.delete();
            }
            catch(Exception e){
                System.out.println("error in release");
            }
            File dump2=new File("slots.txt");
            temp2.renameTo(file2);
        }
        catch(IOException e){
            System.out.print(e);
            System.out.println("Failled unfilling");
        }
    }
    
    //Updates track Records 
    public void update(String track){
        p-=1;
        q+=1;
        slotinfo(p,q);
        System.out.println(track);
        File temp2=new File("temp5.txt");
        File file2=new File("slots.txt");
        try{
            PrintWriter pw = new PrintWriter(new FileOutputStream(temp2,true));
            BufferedReader br = new BufferedReader(new FileReader(file2));
            String r;
            while((r=br.readLine())!=null){
                String[] res=r.split(" ");
                System.out.println(res[0]);

                String trackt=res[0];

                if(trackt.equals(track)){
                    String b=track+" "+"Filled"+" ";
                    pw.println(b);
                }
                else{
                    String bb=track+" "+"Available"+" ";
                    pw.println(r);
                }
       
            }
            System.out.println("Update Slots done");
            pw.flush();
            pw.close();
            br.close();
            try{
                file2.delete();
                System.out.println("file2 deleted");
            }
            catch(Exception e){
                System.out.println("Update Slots File Deleted");
            }
            File dump2=new File("slots.txt");
            temp2.renameTo(file2);              
        }
        catch(IOException e){
            System.out.print(e);
            System.out.println("Update Slots Failed");
        }
    }
    
    //Adds the Information entered into the Jtable
    private void parkButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_parkButActionPerformed

        DefaultTableModel model=(DefaultTableModel)jTable1.getModel();
        String name=nametxt.getText();
        String rc=rctxt.getText();
        String brand=brandtxt.getText();
        String contact=contacttxt.getText();
        String issue=((JTextField)issuetxt.getDateEditor().getUiComponent()).getText();
        String expiry=((JTextField)expirytxt.getDateEditor().getUiComponent()).getText();
        String track=(tracktxt.getSelectedItem()).toString();
        String gender=(gendertxt.getSelectedItem()).toString();
        System.out.println("Reading from fields");
        try{
            int k=0;
            PrintWriter pw=new PrintWriter(new FileOutputStream(new File("data.txt"),true));
            System.out.println("Adding the Entry");
            File file=new File("slots.txt");
            FileReader fr=new FileReader(file);
            String curline;
            String[] data;
            int s=0;
            BufferedReader br=new BufferedReader(fr);
            while((curline=br.readLine())!=null){
                data=curline.split(" ");
               // System.out.println(data[1]+" "+track);
                if(track.equals(data[0])&&data[1].equals("Available")){      
                    System.out.println("Added to file ");
                    String b=rc+" "+name+" "+brand+" "+contact+" "+gender+" "+issue+" "+expiry+" "+track+" ";
                    pw.println(b);
                    pw.flush();
                    //pw.close();
                    JOptionPane.showMessageDialog(this, "Parked");
                    nametxt.setText("");
                    rctxt.setText("");
                    brandtxt.setText("");
                    contacttxt.setText("");
                    ((JTextField)issuetxt.getDateEditor().getUiComponent()).setText("");
                    ((JTextField)expirytxt.getDateEditor().getUiComponent()).setText("");
                    tracktxt.setSelectedItem("");
                    nametxt.requestFocus();
                    deleteAllRows(model);
                    table_update();
                     br.close();
                    update(track);
                   bpt.insert(Integer.parseInt(track),b);
                    
                }
            
            }  
            pw.close();
            
        }
        catch(HeadlessException | IOException e){
            System.out.println("parked");
          
        }
    }//GEN-LAST:event_parkButActionPerformed

    //Removes the Selected Record
    private void ReleaseButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ReleaseButActionPerformed
        DefaultTableModel model=(DefaultTableModel)jTable1.getModel();
        int selected_index=jTable1.getSelectedRow();
        try{
            int id=Integer.parseInt(model.getValueAt(selected_index, 0).toString());
            bpt.delete(id);
            System.out.println("BPT Deleted");
            System.out.println(selected_index);
            int dialog=JOptionPane.showConfirmDialog(null, "Do You want to delete?","Warning",JOptionPane.YES_NO_OPTION);
            if(dialog==JOptionPane.YES_OPTION){
                String curline;
                String[] data;
                String track=null;
                File file=new File("data.txt");
                File temp=new File("temp.txt");
                FileWriter fw=new FileWriter(temp,true);
                BufferedWriter bw=new BufferedWriter(fw);
                PrintWriter pw=new PrintWriter(bw);
                FileReader fr=new FileReader(file);
                int y=0;
                BufferedReader br=new BufferedReader(fr);
                while((curline=br.readLine())!=null){
                data=curline.split(" ");
                System.out.println(y+" "+selected_index);
                if(y!=selected_index){
                pw.println(curline);

                }
                else{
                track=data[7];
                }
                y+=1;
                }
                pw.flush();
                pw.close();
                br.close();
                bw.close();
                fr.close();
                fw.close();
                if(file.delete()){
                System.out.println("Release file deleted");
                }
                File dump=new File("data.txt");
                temp.renameTo(dump);
            model.removeRow(selected_index);
            unfill(track);
            //update(track);
            }
        }
        catch(HeadlessException | IOException | NumberFormatException e){
            System.out.println(e);
        }
    }//GEN-LAST:event_ReleaseButActionPerformed

    //Saves the changed entries to the Jtable
    private void UpdateButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_UpdateButActionPerformed
        DefaultTableModel model=(DefaultTableModel)jTable1.getModel();
        int selected_index=jTable1.getSelectedRow();
           
        int id=Integer.parseInt(model.getValueAt(selected_index, 0).toString());
        String name=nametxt.getText();
        String rc=rctxt.getText();
        String brand=brandtxt.getText();
        String contact=contacttxt.getText();
        String issue=((JTextField)issuetxt.getDateEditor().getUiComponent()).getText();
        String expiry=((JTextField)expirytxt.getDateEditor().getUiComponent()).getText();
        String track=(tracktxt.getSelectedItem()).toString();
        String gender=(gendertxt.getSelectedItem()).toString();

        String path="C:\\Users\\adars\\OneDrive\\Desktop\\FS_Mini\\FS\\ParkingSystem\\data.txt";
        File file=new File(path);
        File temp=new File("temp.txt");
            try (
                    BufferedReader br = new BufferedReader(new FileReader(file)); 
                    PrintWriter pw = new PrintWriter(new FileOutputStream(temp,true))) {           
                String r;
                
                while((r=br.readLine())!=null){
   
                    String[] res=r.split(" ");
                    String rct=res[0];
                    String namet=res[1];
                    String brandt=res[2];
                    String contactt=res[3];
                    String gendert=res[4];
                    String issuet=res[5];
                    String expiryt=res[6];
                    String trackt=res[7];
                    
                    if(rc.equals(rct)){
                        bpt.delete(Integer.parseInt(trackt));
                        
                        String b=rc+" "+name+" "+brand+" "+contact+" "+gender+" "+issue+" "+expiry+" "+track+" ";
                        pw.println(b);
                        bpt.insert(Integer.parseInt(track),b);
                        System.out.println(b);
          
                    }
                    else{
                        String bb=rct+" "+namet+" "+brandt+" "+contactt+" "+gendert+" "+issuet+" "+expiryt+" "+trackt+" ";
                        pw.println(r);
                        System.out.println(bb);
                    }
            
                }
                pw.flush();
                pw.close();
                br.close();
                if(file.delete()){
                    System.out.println("Update File deleted");                      
                }
                File dump=new File("data.txt");
                temp.renameTo(dump);
                deleteAllRows(model);  
                table_update();
               
            }
 
        catch(Exception e){
            System.out.println(e);
            
        }

        
    }//GEN-LAST:event_UpdateButActionPerformed

    //For Selecting a RECORD from the JTable
    private void jTable1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTable1MouseClicked
        DefaultTableModel model=(DefaultTableModel)jTable1.getModel();
        int selected_index=jTable1.getSelectedRow();
        nametxt.setText(model.getValueAt(selected_index, 1).toString());
        rctxt.setText(model.getValueAt(selected_index, 0).toString());
        brandtxt.setText(model.getValueAt(selected_index, 2).toString());
        contacttxt.setText(model.getValueAt(selected_index, 3).toString());
        gendertxt.setSelectedItem(model.getValueAt(selected_index, 4).toString());
        ((JTextField)issuetxt.getDateEditor().getUiComponent()).setText(model.getValueAt(selected_index, 5).toString());
        ((JTextField)expirytxt.getDateEditor().getUiComponent()).setText(model.getValueAt(selected_index, 6).toString());
        tracktxt.setSelectedItem(model.getValueAt(selected_index, 7).toString());

    }//GEN-LAST:event_jTable1MouseClicked
    
    //To clear the Entry boxes
    private void ClearButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ClearButActionPerformed

        nametxt.setText("");
        rctxt.setText("");
        brandtxt.setText("");
        contacttxt.setText("");
        tracktxt.setSelectedItem("");
        ((JTextField)issuetxt.getDateEditor().getUiComponent()).setText("");
        ((JTextField)expirytxt.getDateEditor().getUiComponent()).setText("");
        nametxt.requestFocus();
    }//GEN-LAST:event_ClearButActionPerformed

    //This checks whether the track is free or parked (Shows Free Track for Out of bound Values)
    private void checkButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkButActionPerformed
        try{
            String path="C:\\Users\\adars\\OneDrive\\Desktop\\FS_Mini\\FS\\ParkingSystem\\data.txt";
            File file=new File(path);
            BufferedReader br = new BufferedReader(new FileReader(file));
            {
                String Val,z ;
                Boolean trackStat = true;
                String searchkey = searchtxt.getText();
                while((z= br.readLine()) !=null)
                {
                    String[] result = z.split(" ");
                    Val = result[7];
                    bpt.search(Integer.parseInt(result[7]));
                    if(searchkey.equals(Val)){
                        System.out.println("Check result Parking is Busy");
                        JOptionPane.showMessageDialog(null,"Already Parked!!","Alert",JOptionPane.PLAIN_MESSAGE);
                        trackStat = false;
                        break;
                    }
                }
                if(trackStat){
                    System.out.println("Check result Parking is Free");
                    JOptionPane.showMessageDialog(null,"Free Track!!","Alert",JOptionPane.PLAIN_MESSAGE);
                    
                }
                br.close();
                searchtxt.setText("");

            }
        }
        catch (IOException ex) {
            JOptionPane.showMessageDialog(null,"RC Incorrect. Try Again!","Alert",JOptionPane.WARNING_MESSAGE);
            System.out.println("not found");
            Logger.getLogger(index.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_checkButActionPerformed

    private void unavailabletxtActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_unavailabletxtActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_unavailabletxtActionPerformed

    //THis should generate a report Of the present Status of the Parking
    private void reportExportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_reportExportActionPerformed

        String DirPath="";
        JFileChooser j = new JFileChooser();
        j.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        int v = j.showSaveDialog(this);
        if(v == JFileChooser.APPROVE_OPTION){
            DirPath = j.getSelectedFile().getPath();
        }
        Rectangle pagesize = PageSize.A4;
        Document Doc = new Document(pagesize);
        Float totWidth = 1100f;
        try {
            PdfWriter.getInstance(Doc, new FileOutputStream(DirPath+"/ParkingReport.pdf"));
            Doc.open();
            float[] relativeWidths = {100,130,150,160,120,150,150,90};
            PdfPTable TableA = new PdfPTable(8);
            TableA.setTotalWidth(totWidth);
            TableA.setWidths(relativeWidths);
            //Headers
            TableA.addCell("RC No.");
            TableA.addCell("Name");
            TableA.addCell("Brand");
            TableA.addCell("Contact");
            TableA.addCell("Gender");
            TableA.addCell("Issue");
            TableA.addCell("Expiry");
            TableA.addCell("Track");

            //Data
            for (int k=0; k<jTable1.getRowCount(); k++){

                String RC = jTable1.getValueAt(k,0).toString();
                String NAME = jTable1.getValueAt(k,1).toString();
                String BRAND = jTable1.getValueAt(k,2).toString();
                String CONTACT = jTable1.getValueAt(k,3).toString();
                String GENDER = jTable1.getValueAt(k,4).toString();
                String ISSUE = jTable1.getValueAt(k,5).toString();
                String EXPIY = jTable1.getValueAt(k,6).toString();
                String TRACK = jTable1.getValueAt(k,7).toString();

                TableA.addCell(RC);
                TableA.addCell(NAME);
                TableA.addCell(BRAND);
                TableA.addCell(CONTACT);
                TableA.addCell(GENDER);
                TableA.addCell(ISSUE);
                TableA.addCell(EXPIY);
                TableA.addCell(TRACK);
            }
            String test=" ";
            Paragraph title = new Paragraph ("CAR PARKING REPORT \n");
            Paragraph para1 = new Paragraph ("This is the Current Status of the Parking Space: \n ");
            Doc.add(title);
            Doc.add(para1);
            Doc.add(TableA);

            Doc.close();

        } catch (DocumentException | FileNotFoundException ex) {
            Logger.getLogger(index.class.getName()).log(Level.SEVERE, null, ex);
        }

    }//GEN-LAST:event_reportExportActionPerformed

    private void availabletxtActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_availabletxtActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_availabletxtActionPerformed

       
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) throws FileNotFoundException {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(index.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(index.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(index.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(index.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
                splashScreen ss = new splashScreen();
                ss.setVisible(true);        
                index ind = new index();
                try{
                    for(int i=0; i<100; i++){
                        Thread.sleep(40);
                        ss.progress.setValue(i);
                    }
                    
                }catch(Exception e){
                    System.out.println("Splash Failed");
                }
                ss.setVisible(false);
                ind.setVisible(true);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton ClearBut;
    private javax.swing.JButton ReleaseBut;
    private javax.swing.JButton UpdateBut;
    private javax.swing.JTextField availabletxt;
    private javax.swing.JLabel brand;
    private javax.swing.JTextField brandtxt;
    private javax.swing.JButton checkBut;
    private javax.swing.JTextField contacttxt;
    private com.toedter.calendar.JDateChooser expirytxt;
    private javax.swing.JComboBox<String> gendertxt;
    private com.toedter.calendar.JDateChooser issuetxt;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTable jTable1;
    private javax.swing.JTextField nametxt;
    private javax.swing.JButton parkBut;
    private javax.swing.JTextField rctxt;
    private javax.swing.JButton reportExport;
    private javax.swing.JTextField searchtxt;
    private javax.swing.JComboBox<String> tracktxt;
    private javax.swing.JTextField unavailabletxt;
    // End of variables declaration//GEN-END:variables

    private String toString(String string) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
}

 
class bplustree {
	int m;
	InternalNode root;
	LeafNode firstLeaf;
       
	private int binarySearch(DictionaryPair[] dps, int numPairs, int t) {
            
		Comparator<DictionaryPair> c = new Comparator<DictionaryPair>() {
			@Override
			public int compare(DictionaryPair o1, DictionaryPair o2) {
				Integer a = Integer.valueOf(o1.key);
				Integer b = Integer.valueOf(o2.key);
                                 
				return a.compareTo(b);
			}
		};
                //System.out.println(Arrays.binarySearch(dps, 0, numPairs, new DictionaryPair(t, ""), c)+"kill");
		return Arrays.binarySearch(dps, 0, numPairs, new DictionaryPair(t, ""), c);
	}

	private LeafNode findLeafNode(int key) {

		// Initialize keys and index variable
		Integer[] keys = this.root.keys;
		int i;

		// Find next node on path to appropriate leaf node
		for (i = 0; i < this.root.degree - 1; i++) {
			if (key < keys[i]) { break; }
		}

		/* Return node if it is a LeafNode object,
		   otherwise repeat the search function a level down */
		Node child = this.root.childPointers[i];
		if (child instanceof LeafNode) {
			return (LeafNode)child;
		} else {
			return findLeafNode((InternalNode)child, key);
		}
	}

	private LeafNode findLeafNode(InternalNode node, int key) {

		// Initialize keys and index variable
		Integer[] keys = node.keys;
		int i;

		// Find next node on path to appropriate leaf node
		for (i = 0; i < node.degree - 1; i++) {
			if (key < keys[i]) { break; }
		}

		/* Return node if it is a LeafNode object,
		   otherwise repeat the search function a level down */
		Node childNode = node.childPointers[i];
		if (childNode instanceof LeafNode) {
			return (LeafNode)childNode;
		} else {
			return findLeafNode((InternalNode)node.childPointers[i], key);
		}
	}

	private int findIndexOfPointer(Node[] pointers, LeafNode node) {
		int i;
		for (i = 0; i < pointers.length; i++) {
			if (pointers[i] == node) { break; }
		}
		return i;
	}

	private int getMidpoint() {
		return (int)Math.ceil((this.m + 1) / 2.0) - 1;
	}

	private void handleDeficiency(InternalNode in) {

		InternalNode sibling;
		InternalNode parent = in.parent;

		// Remedy deficient root node
		if (this.root == in) {
			for (int i = 0; i < in.childPointers.length; i++) {
				if (in.childPointers[i] != null) {
					if (in.childPointers[i] instanceof InternalNode) {
						this.root = (InternalNode)in.childPointers[i];
						this.root.parent = null;
					} else if (in.childPointers[i] instanceof LeafNode) {
						this.root = null;
					}
				}
			}
		}

		// Borrow:
		else if (in.leftSibling != null && in.leftSibling.isLendable()) {
			sibling = in.leftSibling;
		} else if (in.rightSibling != null && in.rightSibling.isLendable()) {
			sibling = in.rightSibling;

			// Copy 1 key and pointer from sibling (atm just 1 key)
			int borrowedKey = sibling.keys[0];
			Node pointer = sibling.childPointers[0];

			// Copy root key and pointer into parent
			in.keys[in.degree - 1] = parent.keys[0];
			in.childPointers[in.degree] = pointer;

			// Copy borrowedKey into root
			parent.keys[0] = borrowedKey;

			// Delete key and pointer from sibling
			sibling.removePointer(0);
			Arrays.sort(sibling.keys);
			sibling.removePointer(0);
			shiftDown(in.childPointers, 1);
		}

		// Merge:
		else if (in.leftSibling != null && in.leftSibling.isMergeable()) {

		} else if (in.rightSibling != null && in.rightSibling.isMergeable()) {
			sibling = in.rightSibling;

			// Copy rightmost key in parent to beginning of sibling's keys &
			// delete key from parent
			sibling.keys[sibling.degree - 1] = parent.keys[parent.degree - 2];
			Arrays.sort(sibling.keys, 0, sibling.degree);
			parent.keys[parent.degree - 2] = null;

			// Copy in's child pointer over to sibling's list of child pointers
			for (int i = 0; i < in.childPointers.length; i++) {
				if (in.childPointers[i] != null) {
					sibling.prependChildPointer(in.childPointers[i]);
					in.childPointers[i].parent = sibling;
					in.removePointer(i);
				}
			}

			// Delete child pointer from grandparent to deficient node
			parent.removePointer(in);

			// Remove left sibling
			sibling.leftSibling = in.leftSibling;
		}

		// Handle deficiency a level up if it exists
		if (parent != null && parent.isDeficient()) {
			handleDeficiency(parent);
		}
	}

	private boolean isEmpty() {
		return firstLeaf == null;
	}

	private int linearNullSearch(DictionaryPair[] dps) {
		for (int i = 0; i <  dps.length; i++) {
			if (dps[i] == null) { return i; }
		}
		return -1;
	}

	private int linearNullSearch(Node[] pointers) {
		for (int i = 0; i <  pointers.length; i++) {
			if (pointers[i] == null) { return i; }
		}
		return -1;
	}

	private void shiftDown(Node[] pointers, int amount) {
		Node[] newPointers = new Node[this.m + 1];
		for (int i = amount; i < pointers.length; i++) {
			newPointers[i - amount] = pointers[i];
		}
		pointers = newPointers;
	}

	private void sortDictionary(DictionaryPair[] dictionary) {
		Arrays.sort(dictionary, new Comparator<DictionaryPair>() {
			@Override
			public int compare(DictionaryPair o1, DictionaryPair o2) {
				if (o1 == null && o2 == null) { return 0; }
				if (o1 == null) { return 1; }
				if (o2 == null) { return -1; }
				return o1.compareTo(o2);
			}
		});
	}

	private Node[] splitChildPointers(InternalNode in, int split) {

		Node[] pointers = in.childPointers;
		Node[] halfPointers = new Node[this.m + 1];

		// Copy half of the values into halfPointers while updating original keys
		for (int i = split + 1; i < pointers.length; i++) {
			halfPointers[i - split - 1] = pointers[i];
			in.removePointer(i);
		}

		return halfPointers;
	}

	private DictionaryPair[] splitDictionary(LeafNode ln, int split) {

		DictionaryPair[] dictionary = ln.dictionary;

		/* Initialize two dictionaries that each hold half of the original
		   dictionary values */
		DictionaryPair[] halfDict = new DictionaryPair[this.m];

		// Copy half of the values into halfDict
		for (int i = split; i < dictionary.length; i++) {
			halfDict[i - split] = dictionary[i];
			ln.delete(i);
		}

		return halfDict;
	}
     

	private void splitInternalNode(InternalNode in) {

		// Acquire parent
		InternalNode parent = in.parent;

		// Split keys and pointers in half
		int midpoint = getMidpoint();
		int newParentKey = in.keys[midpoint];
		Integer[] halfKeys = splitKeys(in.keys, midpoint);
		Node[] halfPointers = splitChildPointers(in, midpoint);

		// Change degree of original InternalNode in
		in.degree = linearNullSearch(in.childPointers);

		// Create new sibling internal node and add half of keys and pointers
		InternalNode sibling = new InternalNode(this.m, halfKeys, halfPointers);
		for (Node pointer : halfPointers) {
			if (pointer != null) { pointer.parent = sibling; }
		}

		// Make internal nodes siblings of one another
		sibling.rightSibling = in.rightSibling;
		if (sibling.rightSibling != null) {
			sibling.rightSibling.leftSibling = sibling;
		}
		in.rightSibling = sibling;
		sibling.leftSibling = in;

		if (parent == null) {

			// Create new root node and add midpoint key and pointers
			Integer[] keys = new Integer[this.m];
			keys[0] = newParentKey;
			InternalNode newRoot = new InternalNode(this.m, keys);
			newRoot.appendChildPointer(in);
			newRoot.appendChildPointer(sibling);
			this.root = newRoot;

			// Add pointers from children to parent
			in.parent = newRoot;
			sibling.parent = newRoot;

		} else {

			// Add key to parent
			parent.keys[parent.degree - 1] = newParentKey;
			Arrays.sort(parent.keys, 0, parent.degree);

			// Set up pointer to new sibling
			int pointerIndex = parent.findIndexOfPointer(in) + 1;
			parent.insertChildPointer(sibling, pointerIndex);
			sibling.parent = parent;
		}
	}
         

	private Integer[] splitKeys(Integer[] keys, int split) {

		Integer[] halfKeys = new Integer[this.m];

		// Remove split-indexed value from keys
		keys[split] = null;

		// Copy half of the values into halfKeys while updating original keys
		for (int i = split + 1; i < keys.length; i++) {
			halfKeys[i - split - 1] = keys[i];
			keys[i] = null;
		}

		return halfKeys;
	}

	/*~~~~~~~~~~~~~~~~DELETE, INSERT, SEARCH ~~~~~~~~~~~~~~~~*/
    //DELETE
	public void delete(int key) {
            System.out.println("Delete Called");
		if (isEmpty()) {

			/* Flow of execution goes here when B+ tree has no dictionary pairs */

			System.err.println("Invalid Delete: The B+ tree is currently empty.");

		} else {

			// Get leaf node and attempt to find index of key to delete
			LeafNode ln = (this.root == null) ? this.firstLeaf : findLeafNode(key);
			int dpIndex = binarySearch(ln.dictionary, ln.numPairs, key);


			if (dpIndex < 0) {

				/* Flow of execution goes here when key is absent in B+ tree */

				System.err.println("Invalid Delete: Key unable to be found.");

			} else {

				// Successfully delete the dictionary pair
				ln.delete(dpIndex);

				// Check for deficiencies
				if (ln.isDeficient()) {

					LeafNode sibling;
					InternalNode parent = ln.parent;

					// Borrow: First, check the left sibling, then the right sibling
					if (ln.leftSibling != null &&
						ln.leftSibling.parent == ln.parent &&
						ln.leftSibling.isLendable()) {

						sibling = ln.leftSibling;
						DictionaryPair borrowedDP = sibling.dictionary[sibling.numPairs - 1];

						/* Insert borrowed dictionary pair, sort dictionary,
						   and delete dictionary pair from sibling */
						ln.insert(borrowedDP);
						sortDictionary(ln.dictionary);
						sibling.delete(sibling.numPairs - 1);

						// Update key in parent if necessary
						int pointerIndex = findIndexOfPointer(parent.childPointers, ln);
						if (!(borrowedDP.key >= parent.keys[pointerIndex - 1])) {
							parent.keys[pointerIndex - 1] = ln.dictionary[0].key;
						}

					} else if (ln.rightSibling != null &&
							   ln.rightSibling.parent == ln.parent &&
							   ln.rightSibling.isLendable()) {

						sibling = ln.rightSibling;
						DictionaryPair borrowedDP = sibling.dictionary[0];

						/* Insert borrowed dictionary pair, sort dictionary,
					       and delete dictionary pair from sibling */
						ln.insert(borrowedDP);
						sibling.delete(0);
						sortDictionary(sibling.dictionary);

						// Update key in parent if necessary
						int pointerIndex = findIndexOfPointer(parent.childPointers, ln);
						if (!(borrowedDP.key < parent.keys[pointerIndex])) {
							parent.keys[pointerIndex] = sibling.dictionary[0].key;
						}

					}

					// Merge: First, check the left sibling, then the right sibling
					else if (ln.leftSibling != null &&
							 ln.leftSibling.parent == ln.parent &&
							 ln.leftSibling.isMergeable()) {

						sibling = ln.leftSibling;
						int pointerIndex = findIndexOfPointer(parent.childPointers, ln);

						// Remove key and child pointer from parent
						parent.removeKey(pointerIndex - 1);
						parent.removePointer(ln);

						// Update sibling pointer
						sibling.rightSibling = ln.rightSibling;

						// Check for deficiencies in parent
						if (parent.isDeficient()) {
							handleDeficiency(parent);
						}

					} else if (ln.rightSibling != null &&
							   ln.rightSibling.parent == ln.parent &&
							   ln.rightSibling.isMergeable()) {

						sibling = ln.rightSibling;
						int pointerIndex = findIndexOfPointer(parent.childPointers, ln);

						// Remove key and child pointer from parent
						parent.removeKey(pointerIndex);
						parent.removePointer(pointerIndex);

						// Update sibling pointer
						sibling.leftSibling = ln.leftSibling;
						if (sibling.leftSibling == null) {
							firstLeaf = sibling;
						}

						if (parent.isDeficient()) {
							handleDeficiency(parent);
						}
					}

				} else if (this.root == null && this.firstLeaf.numPairs == 0) {

					/* Flow of execution goes here when the deleted dictionary
					   pair was the only pair within the tree */

					// Set first leaf as null to indicate B+ tree is empty
					this.firstLeaf = null;

				} else {

					/* The dictionary of the LeafNode object may need to be
					   sorted after a successful delete */
					sortDictionary(ln.dictionary);

				}
			}
		
                System.out.println("[[[");
                        for(int i=0;i<ln.dictionary.length;i++){
                           
                    if((ln.dictionary[i]==null)){
                        System.out.println("Order 4");
   
                    }else{
                        System.out.println("i-----" +ln.dictionary[i].key+"    ["+ln.dictionary[i].value+" ]");
                    }
                
            
                }
                             System.out.println("]]]");
                }
                
	}

	//INSERT
	public void insert(int key, String value){
		if (isEmpty()) {

			/* Flow of execution goes here only when first insert takes place */

			// Create leaf node as first node in B plus tree (root is null)
			LeafNode ln = new LeafNode(this.m, new DictionaryPair(key, value));

			// Set as first leaf node (can be used later for in-order leaf traversal)
			this.firstLeaf = ln;

		} else {

			// Find leaf node to insert into
			LeafNode ln = (this.root == null) ? this.firstLeaf :
				findLeafNode(key);
                        System.out.println("Inserting"); 
                     
                        
			// Insert into leaf node fails if node becomes overfull
			if (!ln.insert(new DictionaryPair(key, value))) {

				// Sort all the dictionary pairs with the included pair to be inserted
				ln.dictionary[ln.numPairs] = new DictionaryPair(key, value);
				ln.numPairs++;
				sortDictionary(ln.dictionary);

				// Split the sorted pairs into two halves
				int midpoint = getMidpoint();
				DictionaryPair[] halfDict = splitDictionary(ln, midpoint);

				if (ln.parent == null) {

					/* Flow of execution goes here when there is 1 node in tree */

					// Create internal node to serve as parent, use dictionary midpoint key
					Integer[] parent_keys = new Integer[this.m];
					parent_keys[0] = halfDict[0].key;
					InternalNode parent = new InternalNode(this.m, parent_keys);
					ln.parent = parent;
                                        //print(ln.parent);
                                       // System.out.print(ln.parent+"parent");
					parent.appendChildPointer(ln);

				} else {

					/* Flow of execution goes here when parent exists */

					// Add new key to parent for proper indexing
					int newParentKey = halfDict[0].key;
					ln.parent.keys[ln.parent.degree - 1] = newParentKey;
					Arrays.sort(ln.parent.keys, 0, ln.parent.degree);
				}

				// Create new LeafNode that holds the other half
				LeafNode newLeafNode = new LeafNode(this.m, halfDict, ln.parent);

				// Update child pointers of parent node
				int pointerIndex = ln.parent.findIndexOfPointer(ln) + 1;
				ln.parent.insertChildPointer(newLeafNode, pointerIndex);

				// Make leaf nodes siblings of one another
				newLeafNode.rightSibling = ln.rightSibling;
				if (newLeafNode.rightSibling != null) {
					newLeafNode.rightSibling.leftSibling = newLeafNode;
				}
				ln.rightSibling = newLeafNode;
				newLeafNode.leftSibling = ln;

				if (this.root == null) {

					// Set the root of B+ tree to be the parent
					this.root = ln.parent;
                                           //print(this.root);

				} else {

					/* If parent is overfull, repeat the process up the tree,
			   		   until no deficiencies are found */
					InternalNode in = ln.parent;
					while (in != null) {
						if (in.isOverfull()) {
							splitInternalNode(in);
						} else {
							break;
						}
						in = in.parent;
                                                System.out.print(in+"parent");
					}
				}
                                
			}
                         System.out.println("[[[");
                        for(int i=0;i<ln.dictionary.length;i++){
                           
                    if((ln.dictionary[i]==null)){
                        System.out.println("Order 4");
   
                    }else{
                        System.out.println("i-----" +ln.dictionary[i].key+"    ["+ln.dictionary[i].value+" ]");
                    }
                
            
                }
                             System.out.println("]]]");
		}
               
	}
    
       public void traversePreOrder(StringBuilder sb, InternalNode node) {
    if (node != null) {
        //System.out.print(node.parent+"studpiff");
        sb.append(node.parent);
        sb.append("\n");
        traversePreOrder(sb, node.leftSibling);
        traversePreOrder(sb, node.rightSibling);
    }
}
        public void print(Node ln) {
    StringBuilder sb = new StringBuilder();
    traversePreOrder(sb, this.root);
    System.out.print(sb.toString()+ln.parent+"hi");
}
    
     
	public String search(int key) {
            
		// If B+ tree is completely empty, simply return null
		if (isEmpty()) { return null; }

		// Find leaf node that holds the dictionary key
		LeafNode ln = (this.root == null) ? this.firstLeaf : findLeafNode(key);
                 
		// Perform binary search to find index of key within dictionary
		DictionaryPair[] dps = ln.dictionary;
		int index = binarySearch(dps, ln.numPairs, key);
                //System.out.println(dps.length);
                //System.out.println("Searching"); 
              //  for(int i=0;i<dps.length;i++){
                //    if((dps[i]==null)){
                 //       System.out.println("--Blank--");
   
                   // }else{
                     //   System.out.println("s---" +dps[i].key+"[["+dps[i].value+"]]");
                    //}  
                //}
               
		// If index negative, the key doesn't exist in B+ tree
		if (index < 0) {
			return null;
		} else {
                        //System.out.println("Value Searched");
                        System.out.println(dps[index].value);
			return dps[index].value;
                        
		}
                
                
	}

    //Sets the order of the b+Tree
	public bplustree(int m) {
		this.m = m;
		this.root = null;
	}

	//superclass of InternalNode and LeafNode.
	class Node {
		InternalNode parent;
	}

	private class InternalNode extends Node {
		int maxDegree;
		int minDegree;
		int degree;
		InternalNode leftSibling;
		InternalNode rightSibling;
		Integer[] keys;
		Node[] childPointers;
		
		private void appendChildPointer(Node pointer) {
			this.childPointers[degree] = pointer;
			this.degree++;
		}
		
		private int findIndexOfPointer(Node pointer) {
			for (int i = 0; i < childPointers.length; i++) {
				if (childPointers[i] == pointer) { return i; }
			}
			return -1;
		}
		
		private void insertChildPointer(Node pointer, int index) {
			for (int i = degree - 1; i >= index ;i--) {
				childPointers[i + 1] = childPointers[i];
			}
			this.childPointers[index] = pointer;
			this.degree++;
		}
		
		private boolean isDeficient() {
			return this.degree < this.minDegree;
		}
		
		private boolean isLendable() { return this.degree > this.minDegree; }
		
		private boolean isMergeable() { return this.degree == this.minDegree; }
		
		private boolean isOverfull() {
			return this.degree == maxDegree + 1;
		}
		
		private void prependChildPointer(Node pointer) {
			for (int i = degree - 1; i >= 0 ;i--) {
				childPointers[i + 1] = childPointers[i];
			}
			this.childPointers[0] = pointer;
			this.degree++;
		}
		
		private void removeKey(int index) { this.keys[index] = null; }
		
		private void removePointer(int index) {
			this.childPointers[index] = null;
			this.degree--;
		}
		
		private void removePointer(Node pointer) {
			for (int i = 0; i < childPointers.length; i++) {
				if (childPointers[i] == pointer) { this.childPointers[i] = null; }
			}
			this.degree--;
		}
		
		private InternalNode(int m, Integer[] keys) {
			this.maxDegree = m;
			this.minDegree = (int)Math.ceil(m/2.0);
			this.degree = 0;
			this.keys = keys;
			this.childPointers = new Node[this.maxDegree+1];
		}

		private InternalNode(int m, Integer[] keys, Node[] pointers) {
			this.maxDegree = m;
			this.minDegree = (int)Math.ceil(m/2.0);
			this.degree = linearNullSearch(pointers);
			this.keys = keys;
			this.childPointers = pointers;
		}
	}


	 class LeafNode extends Node {
		int maxNumPairs;
		int minNumPairs;
		int numPairs;
		LeafNode leftSibling;
		LeafNode rightSibling;
		DictionaryPair[] dictionary;


		public void delete(int index) {

			// Delete dictionary pair from leaf
			this.dictionary[index] = null;

			// Decrement numPairs
			numPairs--;
		}


		public boolean insert(DictionaryPair dp) {
			if (this.isFull()) {

				/* Flow of execution goes here when numPairs == maxNumPairs */

				return false;
			} else {

				// Insert dictionary pair, increment numPairs, sort dictionary
				this.dictionary[numPairs] = dp;
				numPairs++;
				Arrays.sort(this.dictionary, 0, numPairs);

				return true;
			}
		}

		public boolean isDeficient() { return numPairs < minNumPairs; }

		public boolean isFull() { return numPairs == maxNumPairs; }

		public boolean isLendable() { return numPairs > minNumPairs; }

		public boolean isMergeable() {
			return numPairs == minNumPairs;
		}

		public LeafNode(int m, DictionaryPair dp) {
			this.maxNumPairs = m - 1;
			this.minNumPairs = (int)(Math.ceil(m/2) - 1);
			this.dictionary = new DictionaryPair[m];
			this.numPairs = 0;
			this.insert(dp);
		}

		public LeafNode(int m, DictionaryPair[] dps, InternalNode parent) {
			this.maxNumPairs = m - 1;
			this.minNumPairs = (int)(Math.ceil(m/2) - 1);
			this.dictionary = dps;
			this.numPairs = linearNullSearch(dps);
			this.parent = parent;
		}
	}

	 class DictionaryPair implements Comparable<DictionaryPair> {
		int key;
		String value;

		public DictionaryPair(int key, String value) {
			this.key = key;
			this.value = value;
                        //System.out.print("d---"+this.key+"[["+this.value+"]]");
		}

		@Override
		public int compareTo(DictionaryPair o) {
			if (key == o.key) { return 0; }
			else if (key > o.key) { return 1; }
			else { return -1; }
		}
	}


}


